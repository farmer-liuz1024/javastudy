
## Sharding-jdbc概览

**ShardingSphere-JDBC**

定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 
它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。

- 适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。
- 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。
- 支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。
 
 <img src="./media/pictures/sharding-jdbc/sharding-jdbc_v5.png" />
 

## 快速入门

**引入maven依赖**

```java
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>shardingsphere-jdbc-core</artifactId>
    <version>5.0.0</version>
</dependency>
```

**规则配置**

Sharding-jdbc可以通过 java、yaml、spring命名空间、spring boot starter这四种方式进行配置。

**创建数据源**

通过 ShardingSphereDataSourceFactory 工厂和规则配置对象获取 ShardingSphereDataSource。 该对象实现自 JDBC 的标准 DataSource 接口，可用于原生 JDBC 开发，或使用 JPA, MyBatis 等 ORM 类库。

##  概览

### 数据分片

#### 背景
    
传统的将数据集中存储单一解决的解决方案，在性能、可用性、运营成本这个三方面已经难以满足海量数据的场景。<br/><br/>
从性能方面来说，由于关系型数据库大多采用的B+树的索引类型，在数据量超过阈值的情况下，索引深度的增加也将使磁盘访问IO的次数增多，进度导致查询性能下降，
同时高并发请求也使得集中式数据库成为系统的最大瓶颈。<br/><br/>

从可用性的方面来说，服务化的无状态型，能够达到较小成本的所以扩容，这必然导致系统的最终压力都落在数据库上面了。而单一的数据节点，或者简单的主从架构，
已经难以承担，数据库的可用性，已成为整个系统的关键。<br/><br/>

从运营成本方面来说，当一个数据库实例中的数据达到阈值以上，对于DBA的运维压力就会增大，数据备份和恢复的时间都将随着数据量的大小愈发不可控，一般来讲，
单一数据库的存储阈值在1T之内都是比较合理的范围。<br/><br/>

传统的关系型数据库无法满足互联网产品场景的情况下，将数据存储至原生支持分布式的NoSql的方案越来越多。但是NoSql对Sql的不兼容性及生态圈的不完善性，使得它们在与关系型数据库的博弈中
始终无法完成致命的一击，而关系型数据库的地位依然不可撼动。<br/><br/>

数据分片是指按照某个维度将存放在单一数据库的数据分散地存放至多个数据库或表中以达到提升性能瓶颈及可用性的效果，数据分片的有效手段是对关系型数据库进行分库和分表。分库分表均可以有效
避免由数据量超过可承受阈值而产生的查询瓶颈。除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库的压力，但却能够提供尽量将分布式事务转化为本地事务的可能，
一旦涉及跨库的更新操作，分布式事务往往会使问题变得更复杂。使用多主多从的分片方式，可以有效规避数据单点，从而提升数据架构的可用性。<br/><br/>

通过分库和分表进行数据的拆分使得各个表的数据量保持阈值以下，以及对数据进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段，数据分片的拆分方式又分为垂直拆分和水平拆分。<br/><br/>

**垂直分片**

垂直分片又成纵向分片，它的核心理念就是专库专用。在拆分之前，一个数据库有多个表构成，每个表对应这不同的业务。而拆分之后，则是按照业务将表归类，分布到不同的数据库中，从而将压力分散至不同的数据库。
下图展示了根据业务需要，将用户表和订单表分片到不同的数据库方案。

 <img src="./media/pictures/sharding-jdbc/vertical_sharding.png" /><br/>
 
 垂直切片往往需要对架构进行调整，通常来讲，是不足以应对互联网业务需求快速变化的；而且它无法从根本上解决数据库的单点瓶颈。不过垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分
 之后，表中的数据量依然超过单节点所能承受的阈值，则需要水平分片来进一步处理。

**水平拆分**

水平拆分又称横向拆分，相对于垂直拆分，它不再将数据根据业务逻辑分类，而且通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或多个表，每个分片仅包含数据的一部分。例如:根据主键分片，
偶数主键入A库（或表），奇数主键入B库（或表），入下图所示：

 <img src="./media/pictures/sharding-jdbc/horizontal_sharding.png" /><br/>

水平分片从理论上来讲，突破了单机数据量处理的瓶颈，并且扩展相对自由，是数据分片的标准方案。

#### 挑战

虽然数据分片解决了性能、可用以及单点备份恢复等问题，但分布式的结构在获得收益的同时，也引入了新的问题。<br/>
1. 面对如此散乱的分片之后的数据，应用开发工程师和数据库管理员对数据库的操作变得异常繁重。因为他们需要知道需要从哪个具体的数据库的子表中获取数据。
2. 能正确运行在单点的sql，在分片之后数据库运行不一定正确。例如：分表导致表名的修改，或者分页、排序、聚合分组等操作的不正确处理。
3. 跨库事务也是分布式数据集群一个棘手的问题。合理的采用分表，可以在降低单表数据量的情况下，尽快使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦问题。在不能避免跨库事务的场景，
有些业务扔需要保持事务的一致性，而基于XA的分布式事务由于在并发度高的场景中性能无法满足需要，从而并未被互联网公司大规模使用。他们大多数采用最终一致性的柔性事务代替强一致性事务。

#### 目标

尽量透明分库分表所带来的影响，让使用方尽快像使用一个数据库一样使用水平分片之后的数据库集群。是Apache ShardingSphere数据切换模块的主要设计目标。


## 核心流程

### 解析引擎

### 路由引擎

根据解析上下文匹配数据库和表的分片策略，并生产路由路径。对于携带分片键的SQL，根据分片键不同可以划分单片路由（分片键的操作符是符号）、多片路由（分片键的操作符是In）和范围路由
（分片键的操作是Between）。不携带分片键的SQL则采用广播路由。<br/>
分片策略通常可以采用数据库内置或用户方配置。数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等等，有用户方配置的分片策略则更加灵活，可以根据用户方需求
定制复合分片策略。如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可。


###### 分片路由

用户根据分片键路由的场景，又细分为直接路由、标准路由、笛卡尔积路由这3中类型。
    
**直接路由**    

满足直接路由的条件相对苛刻，它需要通过Hint（使用HintAPI直接指定路由至库表）方式分片，并且只分库不分表的前提下，则可以避免SQL解析和之后的结果归并。因此它的性能最好，可以执行包括子查询、
自定义函数等复杂的情况的任意SQL。直接路由还可以用户分片键不在SQL中的场景。例如，设置用于数据库分片的键为3

```java
hintManager.setDatabaseShardingValue(3);
```

假如路由算法为 value % 2，当一个逻辑库 t_order 对应 2 个真实库 t_order_0 和 t_order_1 时，路由后 SQL 将在 t_order_1 上执行。下方是使用 API 的代码样例：

```java
String sql = "SELECT * FROM t_order";
try (
        HintManager hintManager = HintManager.getInstance();
        Connection conn = dataSource.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
    hintManager.setDatabaseShardingValue(3);
    try (ResultSet rs = pstmt.executeQuery()) {
        while (rs.next()) {
            //...
        }
    }
}
```



**标准路由**    

标准路由是 ShardingSphere 最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的 SQL。 当分片运算符是等于号时，路由结果将落入单库（表），
当分片运算符是 BETWEEN 或 IN 时，则路由结果不一定落入唯一的库（表），因此一条逻辑 SQL 最终可能被拆分为多条用于执行的真实 SQL。 举例说明，如果按照 order_id 的奇数和偶数进行数据分片，
一个单表查询的 SQL 如下：

```sql
SELECT * FROM t_order WHERE order_id IN (1, 2);
```
那么路由的结果应为：

```sql
SELECT * FROM t_order_0 WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 WHERE order_id IN (1, 2);
```
绑定表的关联查询与单表查询复杂度和性能相当。举例说明，如果一个包含绑定表的关联查询的 SQL 如下：

```sql
SELECT * FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```

那么路由的结果应为：

```sql
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```
可以看到，SQL 拆分的数目与单表是一致的。

**笛卡尔积路由**  
  
笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行。 如果上个示例中的 SQL 并未配置绑定表关系，那么路由的结果应为：
```sql
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```
笛卡尔路由查询性能较低，需谨慎使用。
   
###### 广播路由

对于不携带分片键的 SQL，则采取广播路由的方式。根据 SQL 类型又可以划分为全库表路由、全库路由、全实例路由、单播路由和阻断路由这 5 种类型。

###### 全库表路由

全库表路由用于处理对数据库中与其逻辑表相关的所有真实表的操作，主要包括不带分片键的 DQL 和 DML，以及 DDL 等。例如：

```sql
SELECT * FROM t_order WHERE good_prority IN (1, 10);
```
则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配得上则执行。路由后成为

```sql
SELECT * FROM t_order_0 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_1 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_2 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_3 WHERE good_prority IN (1, 10);
```

###### 全库路由

全库路由用于处理对数据库的操作，包括用于库设置的 SET 类型的数据库管理命令，以及 TCL 这样的事务控制语句。 在这种情况下，会根据逻辑库的名字遍历所有符合名字匹配的真实库，
并在真实库中执行该命令，例如：

```sql
SET autocommit=0;
```

在 t_order 中执行，t_order 有 2 个真实库。则实际会在 t_order_0 和 t_order_1 上都执行这个命令。

###### 全实例路由

全实例路由用于 DCL 操作，授权语句针对的是数据库的实例。无论一个实例中包含多少个 Schema，每个数据库的实例只执行一次。例如：
```sql
CREATE USER customer@127.0.0.1 identified BY '123';
```
这个命令将在所有的真实数据库实例中执行，以确保 customer 用户可以访问每一个实例。

###### 单播路由

单播路由用于获取某一真实表信息的场景，它仅需要从任意库中的任意真实表中获取数据即可。例如：
```sql
DESCRIBE t_order;
```
t_order 的两个真实表 t_order_0，t_order_1 的描述结构相同，所以这个命令在任意真实表上选择执行一次。

###### 阻断路由

阻断路由用于屏蔽 SQL 对数据库的操作，例如：
```sql
USE order_db;
```
这个命令不会在真实数据库中执行，因为 ShardingSphere 采用的是逻辑 Schema 的方式，无需将切换数据库 Schema 的命令发送至数据库中。<br/>
路由引擎的整体结构划分如下图。

 <img src="./media/pictures/sharding-jdbc/route_architecture.png" />

### 改写引擎

### 执行引擎

### 归并引擎



MongoDB是一个可扩展的高性能、开源、面向文档的数据。

**适用场景**

- 网站数据：实时的插入、删除、更新、查询，以及数据的复制性和高度伸缩性
- 缓存：由于高性能，适合作为系统的缓存层，在系统异常重启后缓存可以缓解数据库的压力
- 廉价的存储成本：使用传统型数据库存储数据的成本会比较高
- 高伸缩的场景：非常适合集群模式下组成的数据库，可随时新增节点
- 用于对象及JSON的数据存储：MongDB的BSON数据格式存储非常适合文档格式的存储及查询

**不适用场景**

- 高度的事务系统：例如银行系统、会计系统，对事务要求比较高
- 传统的商业智能系统：会产生高度的sql查询功能，对于这种业务数仓数据库会比较适合

**应用案例**

- 京东：使用MongoDB存储商品信息
- 赶集网：使用MongoDB记录pv的浏览计数
- 奇虎360：使用MongoDB支撑HULK平台每天200亿次的查询
- 百度云：使用MongoDB管理百度云盘中500亿关于文件源信息的记录
- 纽约时报：使用MongoDB存储存储门户网站的新闻信息

## 环境安装

**Window-MongoDB**

MongoDB 提供了可用于 32 位和 64 位系统的预编译二进制包，你可以从MongoDB官网下载安装，MongoDB 预编译二进制包下载地址：<https://www.mongodb.com/try/download/community>
>注意：在 MongoDB 2.2 版本后已经不再支持 Windows XP 系统。最新版本也已经没有了 32 位系统的安装文件。

<img src="./media/pictures/mongodb/mongodb-download.png" />

下载 .msi 文件，下载后双击该文件，按操作提示安装即可。安装过程中，你可以通过点击 "Custom(自定义)" 按钮来设置你的安装目录。
<img src="./media/pictures/mongodb/accpet.png" />

选择自定义模式

<img src="./media/pictures/mongodb/custom.png" />

选择文件路径

<img src="./media/pictures/mongodb/folder-name.png" />

选择数据盘、日志目录

<img src="./media/pictures/mongodb/data-log-directory.png" />

下一步安装 "install mongoDB compass" 不勾选（当然你也可以选择安装它，可能需要更久的安装时间），MongoDB Compass 是一个图形界面管理工具，

<img src="./media/pictures/mongodb/compass.png" />

至此整个安装的过程基本就完成了

<img src="./media/pictures/mongodb/status.png" /><br/>
<img src="./media/pictures/mongodb/finish.png" />

然后再刚才的安装目录（笔者的安装目录是D:\Program Files\MongoDB\Server\5.0\bin），找到mongo.exe双击打开，出现如下界面

<img src="./media/pictures/mongodb/mongo-exe.png" />

这个界面显示了mongodb的基本信息，然后再输入db.statu命名出现如下界面

<img src="./media/pictures/mongodb/db-status.png" />

下面我介绍一下各个参数的含义
```
"db" : "test" ,表示当前是针对"test"这个数据库的描述。想要查看其他数据库，可以先运行$ use datbasename
"collections" : 3,表示当前数据库有多少个collections.可以通过运行show collections查看当前数据库具体有哪些collection.
"objects" : 267,表示当前数据库所有collection总共有多少行数据。显示的数据是一个估计值，并不是非常精确。
"avgObjSize" : 623.2322097378277,表示每行数据是大小，也是估计值，单位是bytes
"dataSize" : 16640,表示当前数据库所有数据的总大小，不是指占有磁盘大小。单位是bytes
"storageSize" : 110592,表示当前数据库占有磁盘大小，单位是bytes,因为mongodb有预分配空间机制，为了防止当有大量数据插入时对磁盘的压力,因此会事先多分配磁盘空间。
"numExtents" : 0,没有什么真实意义
"indexes" : 2 ,表示system.indexes表数据行数。
"indexSize" : 53248,表示索引占有磁盘大小。单位是bytes
```





**Linux-MongoDB**


## 概念解释

**什么是MongoDB**

- MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。
- 在高负载的情况下，添加更多的节点，可以保证服务器性能。
- MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。
- MongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
![avatar](../../../../media/pictures/mongodb-document.png)

**数据库**

数据库是一个集合的物理服务器，一个MongoDB服务器通常包含多个数据库

**集合**

集合存储在数据库中，没有固定的结构，可以插入不通类型的数据库，通常插入的数据是具有一定关联性的。例如插入如下数据到MongoDB中。（当第一个集合插入时集合就创建了）<br/>
 ```
     {"site":"www.baidu.com"}
     {"site":"www.google.com","name":"谷歌"}
     {"site":"www.oschina.cn","name":"开源中国","num":5}
 ```

**文档**

就是一组键值对 key-value

**NOSQlvsMongoDB**

| **SQL术语/概念** | **MongoDB术语/概念** | **解释/说明**                                        |
| ---------------- | -------------------- | ---------------------------------------------------- |
| database         | database             | 数据库                                               |
| table            | collection           | 数据库表/集合                                        |
| row              | document             | 数据记录行/文档                                      |
| column           | field                | 数据属性/字段(域)                                    |
| index            | index                | 索引                                                 |
| table joins      | Embedded Documents   | 表连接,MongoDB3.2提供了Join操作                      |
| primary key      | primary key          | 主键,MongoDB默认自动将_id字段设置为主键,可以手动设置 |

通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：
![avatar](../../../../media/pictures/mysql-mongodb.png)

**ObjectId**

ObjectId类似唯一主键，可以很快的生成和排序，包含12bytes，含义是：

<img src="./media/pictures/mongodb/objectid.jpeg" />

- 前4个字节表示创建unix时间戳，格林威治的UTC时间，比北京时间晚8小时
- 接下来的3个字节是机器标识码
- 接下来的2个字节是进程ip组成的pid
- 最后三个字节是随机数

MongoDB中存储的文档必须有一个_id键，这个键可以是任何类型，但是默认是ObjectId对象，由于ObjectId中保存了创建的时间戳，所以你不需要为你的文档保存时间戳字段，
你可以通过getTimeStamp函数来获取文档的创建时间：
```javascript
> var newObject = ObjectId()
> newObject.getTimestamp()
ISODate("2017-11-25T07:21:10Z")
```

**字符串**

BSON字符串都是UTF-8编码 

**时间戳**

表示当前距离Unix新纪元（1970年1月1号）的毫秒数，日期类型是有符号的，负数表示1970年之前的日期。

```javascript
> var mydate1 = new Date()     //格林尼治时间
> mydate1
ISODate("2018-03-04T14:58:51.233Z")
> typeof mydate1
object
```

```javascript
> var mydate2 = ISODate() //格林尼治时间
> mydate2
ISODate("2018-03-04T15:00:45.479Z")
> typeof mydate2
object
```

**示例文档**
这是一个Json对象键值存储的文档结构
```
{
   _id: ObjectId("57146ec5de7375577083d127")
   title: 'MongoDB Overview', 
   description: 'MongoDB is no sql database',
   by: 'itcast.cn',
   url: 'http://www.itcast.cn',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 100, 
   comments: [  
      {
         user:'user1',
         message: 'My first comment',
         dateCreated: new Date(2011,1,20,2,15),
         like: 0 
      },
      {
         user:'user2',
         message: 'My second comments',
         dateCreated: new Date(2011,1,25,7,45),
         like: 5
      }
   ]
}
```



## 基本操作

### MongoDB创建数据库 ###

**语法**

MongoDB创建数据库的语法格式如下：
```sql
use testdb;
```
如果数据库存在则切换到指定数据库，数据库不存在，则创建数据库。

**实例**
以创建testdb为例
```sql
> use testdb
switched to db testdb
> db
testdb
> 
```
如果你想查看所有数据库，可以使用 show dbs 命令：
```sql
> show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
>
```
啊啊啊，为什么我们创建的testdb不在数据库的列表中， 要显示它，我们需要向 testdb 数据库插入一些数据。
```sql
> db.testdb.insert({"name":"我的mongodb"})
WriteResult({ "nInserted" : 1 })
> show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
testdb  0.000GB
```
Mongodb中默认的数据库为test，如果没有创建新库，插入的数据都会在test数据库中。


### MongoDB删除数据库 ###

**语法**

```sql
db.dropDatabase()
```

**实例**

比如说删除testdb数据，首先切换到testdb数据库,然后执行删除命令,再使用show db命名查看是否已被删除。

```sql
> use testdb
switched to db testdb
>
> db.dropDatabase()
{ "dropped" : "demodb", "ok" : 1 }
> show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
```

### MongoDB创建集合 ###

MongoDB中使用createCollection()来创建集合，语法格式为:
```sql
db.createCollection(name, options)
```
参数说明

- name: 要创建的集合名称
- options: 可选参数, 指定有关内存大小及索引的选项

**实例**

在test库中创建demo集合，然后使用 show collections 或 show tables 命令查看集合，在MongoDB中不需要创建集合，插入数据的时候会自动创建集合
```sql
> use test
switched to db test
> db.createCollection("demo")
{ "ok" : 1 }
>

> db.mydoc.insert({"name" : "我的MongoDB"})
> show collections
mydoc
...
```

### MongoDB删除集合 ###

Mongodb中使用drop()方法删除集合,如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。

**语法格式**

```sql
db.collection.drop()
```
**实例**

在数据库mydb中，先通过show collections命令查询已存在的集合

```sql
>use mydb
switched to db mydb
>show collections
mydoc
>
```

然后删除mydoc，在通过show collections查询mydb中的集合
```sql
>db.mydoc.drop()
true
>

>show collections
>
```
从结果中可以看出 mydoc 集合已被删除。

### MongoDB创建文档 ###

本章介绍如何将数据插入到MongoDB的集合中

**插入文档**

MongoDB使用insert()或save方法向集合中插入文档，语法如下：
```sql
db.COLLECTION_NAME.insert(document)或db.COLLECTION_NAME.save(document)
```
* insert() 若插入的数据主键重复，则会抛出org.springframework.dao.DuplicateKeyException异常，表示主键已存在，不会保持当前数据
* save() 若插入的数据主键存在，则更新数据，否则插入数据。但是在新版本中已经将此方法废弃，可以使用db.collection.insertOne()或db.collection.replaceOne()代替

3.2版本之后新增了db.collection.inertOne()和db.collection.insertMany()
db.collection.insertOne()向集合中插入了一个新的文档，语法格式如下：
```sql
db.collection.insertOne(
   <document>,
   {
      writeConcern: <document>
   }
)
```
db.collection.insertMany()向集合中插入了多个文档，语法格式如下：
```sql
db.collection.insertMany(
   [ <document 1> , <document 2>, ... ],
   {
      writeConcern: <document>,
      ordered: <boolean>
   }
)
```
参数说明
* document：要写入的文档
* writeConcern：写入策略，默认为1表示要求写确认，0为不要求
* orderd：指定是否顺序写入，默认为true，按顺序写入

### MongoDB更新文档 ###

### MongoDB删除文档 ###

### MongoDB查询文档 ###

## 高级操作











