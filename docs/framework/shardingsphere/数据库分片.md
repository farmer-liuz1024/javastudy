
## Sharding-jdbc概览

**ShardingSphere-JDBC**

定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 
它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。

- 适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。
- 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。
- 支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。
 
 <img src="./media/pictures/sharding-jdbc/sharding-jdbc_v5.png" />
 

## 快速入门

**引入maven依赖**

```java
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>shardingsphere-jdbc-core</artifactId>
    <version>5.0.0</version>
</dependency>
```

**规则配置**

Sharding-jdbc可以通过 java、yaml、spring命名空间、spring boot starter这四种方式进行配置。

**创建数据源**

通过 ShardingSphereDataSourceFactory 工厂和规则配置对象获取 ShardingSphereDataSource。 该对象实现自 JDBC 的标准 DataSource 接口，可用于原生 JDBC 开发，或使用 JPA, MyBatis 等 ORM 类库。

##  概览

### 数据分片

#### 背景
    
传统的将数据集中存储单一解决的解决方案，在性能、可用性、运营成本这个三方面已经难以满足海量数据的场景。<br/><br/>
从性能方面来说，由于关系型数据库大多采用的B+树的索引类型，在数据量超过阈值的情况下，索引深度的增加也将使磁盘访问IO的次数增多，进度导致查询性能下降，
同时高并发请求也使得集中式数据库成为系统的最大瓶颈。<br/><br/>

从可用性的方面来说，服务化的无状态型，能够达到较小成本的所以扩容，这必然导致系统的最终压力都落在数据库上面了。而单一的数据节点，或者简单的主从架构，
已经难以承担，数据库的可用性，已成为整个系统的关键。<br/><br/>

从运营成本方面来说，当一个数据库实例中的数据达到阈值以上，对于DBA的运维压力就会增大，数据备份和恢复的时间都将随着数据量的大小愈发不可控，一般来讲，
单一数据库的存储阈值在1T之内都是比较合理的范围。<br/><br/>

传统的关系型数据库无法满足互联网产品场景的情况下，将数据存储至原生支持分布式的NoSql的方案越来越多。但是NoSql对Sql的不兼容性及生态圈的不完善性，使得它们在与关系型数据库的博弈中
始终无法完成致命的一击，而关系型数据库的地位依然不可撼动。<br/><br/>

数据分片是指按照某个维度将存放在单一数据库的数据分散地存放至多个数据库或表中以达到提升性能瓶颈及可用性的效果，数据分片的有效手段是对关系型数据库进行分库和分表。分库分表均可以有效
避免由数据量超过可承受阈值而产生的查询瓶颈。除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库的压力，但却能够提供尽量将分布式事务转化为本地事务的可能，
一旦涉及跨库的更新操作，分布式事务往往会使问题变得更复杂。使用多主多从的分片方式，可以有效规避数据单点，从而提升数据架构的可用性。<br/><br/>

通过分库和分表进行数据的拆分使得各个表的数据量保持阈值以下，以及对数据进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段，数据分片的拆分方式又分为垂直拆分和水平拆分。<br/><br/>

**垂直分片**

垂直分片又成纵向分片，它的核心理念就是专库专用。在拆分之前，一个数据库有多个表构成，每个表对应这不同的业务。而拆分之后，则是按照业务将表归类，分布到不同的数据库中，从而将压力分散至不同的数据库。
下图展示了根据业务需要，将用户表和订单表分片到不同的数据库方案。

 <img src="./media/pictures/sharding-jdbc/vertical_sharding.png" /><br/>
 
 垂直切片往往需要对架构进行调整，通常来讲，是不足以应对互联网业务需求快速变化的；而且它无法从根本上解决数据库的单点瓶颈。不过垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分
 之后，表中的数据量依然超过单节点所能承受的阈值，则需要水平分片来进一步处理。

**水平拆分**

水平拆分又称横向拆分，相对于垂直拆分，它不再将数据根据业务逻辑分类，而且通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或多个表，每个分片仅包含数据的一部分。例如:根据主键分片，
偶数主键入A库（或表），奇数主键入B库（或表），入下图所示：

 <img src="./media/pictures/sharding-jdbc/horizontal_sharding.png" /><br/>

水平分片从理论上来讲，突破了单机数据量处理的瓶颈，并且扩展相对自由，是数据分片的标准方案。

#### 挑战

虽然数据分片解决了性能、可用以及单点备份恢复等问题，但分布式的结构在获得收益的同时，也引入了新的问题。<br/>
1. 面对如此散乱的分片之后的数据，应用开发工程师和数据库管理员对数据库的操作变得异常繁重。因为他们需要知道需要从哪个具体的数据库的子表中获取数据。
2. 能正确运行在单点的sql，在分片之后数据库运行不一定正确。例如：分表导致表名的修改，或者分页、排序、聚合分组等操作的不正确处理。
3. 跨库事务也是分布式数据集群一个棘手的问题。合理的采用分表，可以在降低单表数据量的情况下，尽快使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦问题。在不能避免跨库事务的场景，
有些业务扔需要保持事务的一致性，而基于XA的分布式事务由于在并发度高的场景中性能无法满足需要，从而并未被互联网公司大规模使用。他们大多数采用最终一致性的柔性事务代替强一致性事务。

#### 目标

尽量透明分库分表所带来的影响，让使用方尽快像使用一个数据库一样使用水平分片之后的数据库集群。是Apache ShardingSphere数据切换模块的主要设计目标。


## 分片引擎

### 解析引擎

### 路由引擎

根据解析上下文匹配数据库和表的分片策略，并生产路由路径。对于携带分片键的SQL，根据分片键不同可以划分单片路由（分片键的操作符是符号）、多片路由（分片键的操作符是In）和范围路由
（分片键的操作是Between）。不携带分片键的SQL则采用广播路由。<br/>
分片策略通常可以采用数据库内置或用户方配置。数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等等，有用户方配置的分片策略则更加灵活，可以根据用户方需求
定制复合分片策略。如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可。


###### 分片路由

用户根据分片键路由的场景，又细分为直接路由、标准路由、笛卡尔积路由这3中类型。
    
**直接路由**    

满足直接路由的条件相对苛刻，它需要通过Hint（使用HintAPI直接指定路由至库表）方式分片，并且只分库不分表的前提下，则可以避免SQL解析和之后的结果归并。因此它的性能最好，可以执行包括子查询、
自定义函数等复杂的情况的任意SQL。直接路由还可以用户分片键不在SQL中的场景。例如，设置用于数据库分片的键为3

```java
hintManager.setDatabaseShardingValue(3);
```

假如路由算法为 value % 2，当一个逻辑库 t_order 对应 2 个真实库 t_order_0 和 t_order_1 时，路由后 SQL 将在 t_order_1 上执行。下方是使用 API 的代码样例：

```java
String sql = "SELECT * FROM t_order";
try (
        HintManager hintManager = HintManager.getInstance();
        Connection conn = dataSource.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
    hintManager.setDatabaseShardingValue(3);
    try (ResultSet rs = pstmt.executeQuery()) {
        while (rs.next()) {
            //...
        }
    }
}
```



**标准路由**    

标准路由是 ShardingSphere 最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的 SQL。 当分片运算符是等于号时，路由结果将落入单库（表），
当分片运算符是 BETWEEN 或 IN 时，则路由结果不一定落入唯一的库（表），因此一条逻辑 SQL 最终可能被拆分为多条用于执行的真实 SQL。 举例说明，如果按照 order_id 的奇数和偶数进行数据分片，
一个单表查询的 SQL 如下：

```sql
SELECT * FROM t_order WHERE order_id IN (1, 2);
```
那么路由的结果应为：

```sql
SELECT * FROM t_order_0 WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 WHERE order_id IN (1, 2);
```
绑定表的关联查询与单表查询复杂度和性能相当。举例说明，如果一个包含绑定表的关联查询的 SQL 如下：

```sql
SELECT * FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```

那么路由的结果应为：

```sql
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```
可以看到，SQL 拆分的数目与单表是一致的。

**笛卡尔积路由**  
  
笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行。 如果上个示例中的 SQL 并未配置绑定表关系，那么路由的结果应为：
```sql
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```
笛卡尔路由查询性能较低，需谨慎使用。
   
###### 广播路由

对于不携带分片键的 SQL，则采取广播路由的方式。根据 SQL 类型又可以划分为全库表路由、全库路由、全实例路由、单播路由和阻断路由这 5 种类型。

###### 全库表路由

全库表路由用于处理对数据库中与其逻辑表相关的所有真实表的操作，主要包括不带分片键的 DQL 和 DML，以及 DDL 等。例如：

```sql
SELECT * FROM t_order WHERE good_prority IN (1, 10);
```
则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配得上则执行。路由后成为

```sql
SELECT * FROM t_order_0 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_1 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_2 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_3 WHERE good_prority IN (1, 10);
```

###### 全库路由

全库路由用于处理对数据库的操作，包括用于库设置的 SET 类型的数据库管理命令，以及 TCL 这样的事务控制语句。 在这种情况下，会根据逻辑库的名字遍历所有符合名字匹配的真实库，
并在真实库中执行该命令，例如：

```sql
SET autocommit=0;
```

在 t_order 中执行，t_order 有 2 个真实库。则实际会在 t_order_0 和 t_order_1 上都执行这个命令。

###### 全实例路由

全实例路由用于 DCL 操作，授权语句针对的是数据库的实例。无论一个实例中包含多少个 Schema，每个数据库的实例只执行一次。例如：
```sql
CREATE USER customer@127.0.0.1 identified BY '123';
```
这个命令将在所有的真实数据库实例中执行，以确保 customer 用户可以访问每一个实例。

###### 单播路由

单播路由用于获取某一真实表信息的场景，它仅需要从任意库中的任意真实表中获取数据即可。例如：
```sql
DESCRIBE t_order;
```
t_order 的两个真实表 t_order_0，t_order_1 的描述结构相同，所以这个命令在任意真实表上选择执行一次。

###### 阻断路由

阻断路由用于屏蔽 SQL 对数据库的操作，例如：
```sql
USE order_db;
```
这个命令不会在真实数据库中执行，因为 ShardingSphere 采用的是逻辑 Schema 的方式，无需将切换数据库 Schema 的命令发送至数据库中。<br/>
路由引擎的整体结构划分如下图。

 <img src="./media/pictures/sharding-jdbc/route_architecture.png" />

### 改写引擎

工程师面向逻辑库与逻辑表书写的 SQL，并不能够直接在真实的数据库中执行，SQL 改写用于将逻辑 SQL 改写为在真实数据库中可以正确执行的 SQL。 它包括正确性改写和优化改写两部分。

**正确性改写**

在包含分表的场景中，需要将分表配置中的逻辑表名称改写为路由之后所获取的真实表名称。仅分库则不需要表名称的改写。除此之外，还包括补列和分页信息修正等内容。

**标识符改写**

需要改写的标识符包括表名称、索引名称以及 Schema 名称。<br/>

表名称改写是指将找到逻辑表在原始 SQL 中的位置，并将其改写为真实表的过程。表名称改写是一个典型的需要对 SQL 进行解析的场景。 从一个最简单的例子开始，若逻辑 SQL 为：
```sql
SELECT order_id FROM t_order WHERE order_id=1;
```
假设该 SQL 配置分片键 order_id，并且 order_id=1 的情况，将路由至分片表 1。那么改写之后的 SQL 应该为：
```sql
SELECT order_id FROM t_order_1 WHERE order_id=1;
```
在这种最简单的 SQL 场景中，是否将 SQL 解析为抽象语法树似乎无关紧要，只要通过字符串查找和替换就可以达到 SQL 改写的效果。
但是下面的场景，就无法仅仅通过字符串的查找替换来正确的改写 SQL 了：
```sql
SELECT order_id FROM t_order WHERE order_id=1 AND remarks=' t_order xxx';
```
正确改写的 SQL 应该是：
```sql
SELECT order_id FROM t_order_1 WHERE order_id=1 AND remarks=' t_order xxx';
```
而非
```sql
SELECT order_id FROM t_order_1 WHERE order_id=1 AND remarks=' t_order_1 xxx';
```
由于表名之外可能含有表名称的类似字符，因此不能通过简单的字符串替换的方式去改写 SQL。<br/>
下面再来看一个更加复杂的 SQL 改写场景：
```sql
SELECT t_order.order_id FROM t_order WHERE t_order.order_id=1 AND remarks=' t_order xxx';
```
上面的 SQL 将表名作为字段的标识符，因此在 SQL 改写时需要一并修改：
```sql
SELECT t_order_1.order_id FROM t_order_1 WHERE t_order_1.order_id=1 AND remarks=' t_order xxx';
```
而如果 SQL 中定义了表的别名，则无需连同别名一起修改，即使别名与表名相同亦是如此。例如：
```sql
SELECT t_order.order_id FROM t_order AS t_order WHERE t_order.order_id=1 AND remarks=' t_order xxx';
```
SQL 改写则仅需要改写表名称就可以了：
```sql
SELECT t_order.order_id FROM t_order_1 AS t_order WHERE t_order.order_id=1 AND remarks=' t_order xxx';
```

**补列**

需要在查询语句中补列通常由两种情况导致。 第一种情况是 ShardingSphere 需要在结果归并时获取相应数据，但该数据并未能通过查询的 SQL 返回。 
这种情况主要是针对 GROUP BY 和 ORDER BY。结果归并时，需要根据 GROUP BY 和 ORDER BY 的字段项进行分组和排序，
但如果原始 SQL 的选择项中若并未包含分组项或排序项，则需要对原始 SQL 进行改写。 先看一下原始 SQL 中带有结果归并所需信息的场景：
```sql
SELECT order_id, user_id FROM t_order ORDER BY user_id;
```
由于使用 user_id 进行排序，在结果归并中需要能够获取到 user_id 的数据，而上面的 SQL 是能够获取到 user_id 数据的，因此无需补列。<br/>
如果选择项中不包含结果归并时所需的列，则需要进行补列，如以下 SQL：
```sql
SELECT order_id FROM t_order ORDER BY user_id;
```
由于原始 SQL 中并不包含需要在结果归并中需要获取的 user_id，因此需要对 SQL 进行补列改写。补列之后的 SQL 是：
```sql
SELECT order_id, user_id AS ORDER_BY_DERIVED_0 FROM t_order ORDER BY user_id;
```
值得一提的是，补列只会补充缺失的列，不会全部补充，而且，在 SELECT 语句中包含 * 的 SQL，也会根据表的元数据信息选择性补列。下面是一个较为复杂的 SQL 补列场景：
```sql
SELECT o.* FROM t_order o, t_order_item i WHERE o.order_id=i.order_id ORDER BY user_id, order_item_id;
```
我们假设只有 t_order_item 表中包含 order_item_id 列，那么根据表的元数据信息可知，在结果归并时，排序项中的 user_id 是存在于 t_order 表中的，无需补列；
order_item_id 并不在 t_order 中，因此需要补列。 补列之后的 SQL 是：
```sql
SELECT o.*, order_item_id AS ORDER_BY_DERIVED_0 FROM t_order o, t_order_item i WHERE o.order_id=i.order_id ORDER BY user_id, order_item_id;
```
补列的另一种情况是使用 AVG 聚合函数。在分布式的场景中，使用 avg1 + avg2 + avg3 / 3 计算平均值并不正确，需要改写为 (sum1 + sum2 + sum3) / (count1 + count2 + count3)。
这就需要将包含 AVG 的 SQL 改写为 SUM 和 COUNT，并在结果归并时重新计算平均值。例如以下 SQL：
```sql
SELECT AVG(price) FROM t_order WHERE user_id=1;
```
需要改写为：
```sql
SELECT COUNT(price) AS AVG_DERIVED_COUNT_0, SUM(price) AS AVG_DERIVED_SUM_0 FROM t_order WHERE user_id=1;
```
然后才能够通过结果归并正确的计算平均值。<br/>

最后一种补列是在执行 INSERT 的 SQL 语句时，如果使用数据库自增主键，是无需写入主键字段的。 但数据库的自增主键是无法满足分布式场景下的主键唯一的
，因此 ShardingSphere 提供了分布式自增主键的生成策略，并且可以通过补列，让使用方无需改动现有代码，即可将分布式自增主键透明的替换数据库现有的自增主键。
 分布式自增主键的生成策略将在下文中详述，这里只阐述与 SQL 改写相关的内容。 举例说明，假设表 t_order 的主键是 order_id，原始的 SQL 为：
```sql
INSERT INTO t_order (`field1`, `field2`) VALUES (10, 1);
```
可以看到，上述 SQL 中并未包含自增主键，是需要数据库自行填充的。ShardingSphere 配置自增主键后，SQL 将改写为：
```sql
INSERT INTO t_order (`field1`, `field2`, order_id) VALUES (10, 1, xxxxx);
```
改写后的 SQL 将在 INSERT FIELD 和 INSERT VALUE 的最后部分增加主键列名称以及自动生成的自增主键值。上述 SQL 中的 xxxxx 表示自动生成的自增主键值。
如果 INSERT 的 SQL 中并未包含表的列名称，ShardingSphere 也可以根据判断参数个数以及表元信息中的列数量对比，并自动生成自增主键。例如，原始的 SQL 为：
```sql
INSERT INTO t_order VALUES (10, 1);
```
改写的 SQL 将只在主键所在的列顺序处增加自增主键即可：
```sql
INSERT INTO t_order VALUES (xxxxx, 10, 1);
```
自增主键补列时，如果使用占位符的方式书写 SQL，则只需要改写参数列表即可，无需改写 SQL 本身。

**分页修正**

从多个数据库获取分页数据与单数据库的场景是不同的。 假设每 10 条数据为一页，取第 2 页数据。在分片环境下获取 LIMIT 10, 10，
归并之后再根据排序条件取出前 10 条数据是不正确的。 举例说明，若 SQL 为：
```sql
SELECT score FROM t_score ORDER BY score DESC LIMIT 1, 2;
```
下图展示了不进行 SQL 的改写的分页执行结果。

<img src="./media/pictures/sharding-jdbc/pagination_without_rewrite.png" />
通过图中所示，想要取得两个表中共同的按照分数排序的第 2 条和第 3 条数据，应该是 95 和 90。 由于执行的 SQL 只能从每个表中获取第 2 条和第 3 条数据，
即从 t_score_0 表中获取的是 90 和 80；从 t_score_1 表中获取的是 85 和 75。 因此进行结果归并时，只能从获取的 90，80，85 和 75 之中进行归并，
那么结果归并无论怎么实现，都不可能获得正确的结果。正确的做法是将分页条件改写为 LIMIT 0, 3，取出所有前两页数据，再结合排序条件计算出正确的数据。 
下图展示了进行 SQL 改写之后的分页执行结果。
<img src="./media/pictures/sharding-jdbc/pagination_with_rewrite.png" /> 
越获取偏移量位置靠后数据，使用 LIMIT 分页方式的效率就越低。 有很多方法可以避免使用 LIMIT 进行分页。比如构建行记录数量与行偏移量的二级索引，
或使用上次分页数据结尾 ID 作为下次查询条件的分页方式等。分页信息修正时，如果使用占位符的方式书写 SQL，则只需要改写参数列表即可，无需改写 SQL 本身。

**批量拆分**

在使用批量插入的 SQL 时，如果插入的数据是跨分片的，那么需要对 SQL 进行改写来防止将多余的数据写入到数据库中。 插入操作与查询操作的不同之处在于，
查询语句中即使用了不存在于当前分片的分片键，也不会对数据产生影响；而插入操作则必须将多余的分片键删除。 举例说明，如下 SQL：
```sql
INSERT INTO t_order (order_id, xxx) VALUES (1, 'xxx'), (2, 'xxx'), (3, 'xxx');
```
假设数据库仍然是按照 order_id 的奇偶值分为两片的，仅将这条 SQL 中的表名进行修改，然后发送至数据库完成 SQL 的执行 ，则两个分片都会写入相同的记录。 
虽然只有符合分片查询条件的数据才能够被查询语句取出，但存在冗余数据的实现方案并不合理。因此需要将 SQL 改写为：
```sql
INSERT INTO t_order_0 (order_id, xxx) VALUES (2, 'xxx');
INSERT INTO t_order_1 (order_id, xxx) VALUES (1, 'xxx'), (3, 'xxx');
```
使用 IN 的查询与批量插入的情况相似，不过 IN 操作并不会导致数据查询结果错误。通过对 IN 查询的改写，可以进一步的提升查询性能。如以下 SQL：
```sql
SELECT * FROM t_order WHERE order_id IN (1, 2, 3);
```
改写为：
```sql
SELECT * FROM t_order_0 WHERE order_id IN (2);
SELECT * FROM t_order_1 WHERE order_id IN (1, 3);
```
可以进一步的提升查询性能。ShardingSphere 暂时还未实现此改写策略，目前的改写结果是：
```sql
SELECT * FROM t_order_0 WHERE order_id IN (1, 2, 3);
SELECT * FROM t_order_1 WHERE order_id IN (1, 2, 3);
```
虽然 SQL 的执行结果是正确的，但并未达到最优的查询效率。

**优化改写**

优化改写的目的是在不影响查询正确性的情况下，对性能进行提升的有效手段。它分为单节点优化和流式归并优化。

**单节点优化**

路由至单节点的 SQL，则无需优化改写。 当获得一次查询的路由结果后，如果是路由至唯一的数据节点，则无需涉及到结果归并。
因此补列和分页信息等改写都没有必要进行。 尤其是分页信息的改写，无需将数据从第 1 条开始取，大量的降低了对数据库的压力，并且节省了网络带宽的无谓消耗。

**流式归并优化**

它仅为包含 GROUP BY 的 SQL 增加 ORDER BY 以及和分组项相同的排序项和排序顺序，用于将内存归并转化为流式归并。 
在结果归并的部分中，将对流式归并和内存归并进行详细说明。改写引擎的整体结构划分如下图所示。

### 执行引擎

ShardingSphere 采用一套自动化的执行引擎，负责将路由和改写完成之后的真实 SQL 安全且高效发送到底层数据源执行。 它不是简单地将 SQL 通过 JDBC 直接发送至数据源执行；
也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题。 执行引擎的目标是自动化的平衡资源控制与执行效率。

**连接模式**

从资源控制的角度看，业务方访问数据库的连接数量应当有所限制。 它能够有效地防止某一业务操作过多的占用资源，从而将数据库连接的资源耗尽，以致于影响其他业务的正常访问。 
特别是在一个数据库实例中存在较多分表的情况下，一条不包含分片键的逻辑 SQL 将产生落在同库不同表的大量真实 SQL ，如果每条真实SQL都占用一个独立的连接，那么一次查询无疑将会占用过多的资源。<br/>

从执行效率的角度看，为每个分片查询维持一个独立的数据库连接，可以更加有效的利用多线程来提升执行效率。 为每个数据库连接开启独立的线程，可以将 I/O 所产生的消耗并行处理。
为每个分片维持一个独立的数据库连接，还能够避免过早的将查询结果数据加载至内存。 独立的数据库连接，能够持有查询结果集游标位置的引用，在需要获取相应数据时移动游标即可。<br/>

以结果集游标下移进行结果归并的方式，称之为流式归并，它无需将结果数据全数加载至内存，可以有效的节省内存资源，进而减少垃圾回收的频次。 当无法保证每个分片查询持有
一个独立数据库连接时，则需要在复用该数据库连接获取下一张分表的查询结果集之前，将当前的查询结果集全数加载至内存。 因此，即使可以采用流式归并，在此场景下也将退化为内存归并。<br/>

以结果集游标下移进行结果归并的方式，称之为流式归并，它无需将结果数据全数加载至内存，可以有效的节省内存资源，进而减少垃圾回收的频次。 当无法保证每个分片查询持有一个独立数
据库连接时，则需要在复用该数据库连接获取下一张分表的查询结果集之前，将当前的查询结果集全数加载至内存。 因此，即使可以采用流式归并，在此场景下也将退化为内存归并。<br/>

一方面是对数据库连接资源的控制保护，一方面是采用更优的归并模式达到对中间件内存资源的节省，如何处理好两者之间的关系，是 ShardingSphere 执行引擎需要解决的问题。
具体来说，如果一条 SQL 在经过 ShardingSphere 的分片后，需要操作某数据库实例下的 200 张表。 那么，是选择创建 200 个连接并行执行，还是选择创建一个连接串行执行呢？
效率与资源控制又应该如何抉择呢？<br/>

针对上述场景，ShardingSphere 提供了一种解决思路。 它提出了连接模式（Connection Mode）的概念，将其划分为内存限制模式（MEMORY_STRICTLY）和连接限制模式（CONNECTION_STRICTLY）这两种类型。<br/>

**内存限制模式**

使用此模式的前提是，ShardingSphere 对一次操作所耗费的数据库连接数量不做限制。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，则对每张表创建一个新的数据库连接，
并通过多线程的方式并发处理，以达成执行效率最大化。 并且在 SQL 满足条件情况下，优先选择流式归并，以防止出现内存溢出或避免频繁垃圾回收情况。<br/>

**连接限制模式**
使用此模式的前提是，ShardingSphere 严格控制对一次操作所耗费的数据库连接数量。 如果实际执行的 SQL 需要对某数据库实例中的 200 张表做操作，那么只会创建唯一的数据库连接，
并对其 200 张表串行处理。 如果一次操作中的分片散落在不同的数据库，仍然采用多线程处理对不同库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。
这样即可以防止对一次请求对数据库连接占用过多所带来的问题。该模式始终选择内存归并。<br/>

内存限制模式适用于 OLAP 操作，可以通过放宽对数据库连接的限制提升系统吞吐量； 连接限制模式适用于 OLTP 操作，OLTP 通常带有分片键，会路由到单一的分片，
因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。<br/>

**自动化执行引擎**

ShardingSphere 最初将使用何种模式的决定权交由用户配置，让开发者依据自己业务的实际场景需求选择使用内存限制模式或连接限制模式。<br/>

这种解决方案将两难的选择的决定权交由用户，使得用户必须要了解这两种模式的利弊，并依据业务场景需求进行选择。 这无疑增加了用户对 ShardingSphere 的学习和使用的成本，并非最优方案。<br/>

这种一分为二的处理方案，将两种模式的切换交由静态的初始化配置，是缺乏灵活应对能力的。在实际的使用场景中，面对不同 SQL 以及占位符参数，每次的路由结果是不同的。 这就意味着某些操作可能需要使用内存归并，
而某些操作则可能选择流式归并更优，具体采用哪种方式不应该由用户在 ShardingSphere 启动之前配置好，而是应该根据 SQL 和占位符参数的场景，来动态的决定连接模式。<br/>

为了降低用户的使用成本以及连接模式动态化这两个问题，ShardingSphere 提炼出自动化执行引擎的思路，在其内部消化了连接模式概念。 
用户无需了解所谓的内存限制模式和连接限制模式是什么，而是交由执行引擎根据当前场景自动选择最优的执行方案。<br/>

自动化执行引擎将连接模式的选择粒度细化至每一次 SQL 的操作。 针对每次 SQL 请求，自动化执行引擎都将根据其路由结果，进行实时的演算和权衡，并自主地采用恰当的连接模式执行，
以达到资源控制和效率的最优平衡。 针对自动化的执行引擎，用户只需配置 maxConnectionSizePerQuery 即可，该参数表示一次查询时每个数据库所允许使用的最大连接数。<br/>

执行引擎分为准备和执行两个阶段。<br/>

**准备阶段**

顾名思义，此阶段用于准备执行的数据。它分为结果集分组和执行单元创建两个步骤。<br/>

结果集分组是实现内化连接模式概念的关键。执行引擎根据 maxConnectionSizePerQuery 配置项，结合当前路由结果，选择恰当的连接模式。 具体步骤如下：

1. 将 SQL 的路由结果按照数据源的名称进行分组。
2. 通过下图的公式，可以获得每个数据库实例在 maxConnectionSizePerQuery 的允许范围内，每个连接需要执行的 SQL 路由结果组，并计算出本次请求的最优连接模式。
<img src="./media/pictures/sharding-jdbc/connection_mode_cn.png" />

在 maxConnectionSizePerQuery 允许的范围内，当一个连接需要执行的请求数量大于 1 时，意味着当前的数据库连接无法持有相应的数据结果集，则必须采用内存归并； 反之，
当一个连接需要执行的请求数量等于 1 时，意味着当前的数据库连接可以持有相应的数据结果集，则可以采用流式归并。<br/>

每一次的连接模式的选择，是针对每一个物理数据库的。也就是说，在同一次查询中，如果路由至一个以上的数据库，每个数据库的连接模式不一定一样，它们可能是混合存在的形态。<br/>

通过上一步骤获得的路由分组结果创建执行的单元。 当数据源使用数据库连接池等控制数据库连接数量的技术时，在获取数据库连接时，如果不妥善处理并发，则有一定几率发生死锁。<br/> 
在多个请求相互等待对方释放数据库连接资源时，将会产生饥饿等待，造成交叉的死锁问题。

举例说明，假设一次查询需要在某一数据源上获取两个数据库连接，并路由至同一个数据库的两个分表查询。 则有可能出现查询 A 已获取到该数据源的 1 个数据库连接，并等待获取另一个数据库连接；
而查询 B 也已经在该数据源上获取到的一个数据库连接，并同样等待另一个数据库连接的获取。 如果数据库连接池的允许最大连接数是 2，那么这 2 个查询请求将永久的等待下去。下图描绘了死锁的情况。<br/>
<img src="./media/pictures/sharding-jdbc/dead_lock_cn.png" />

ShardingSphere 为了避免死锁的出现，在获取数据库连接时进行了同步处理。 它在创建执行单元时，以原子性的方式一次性获取本次 SQL 请求所需的全部数据库连接，杜绝了每次查询请求获取到部分资源的可能。<br/>
 由于对数据库的操作非常频繁，每次获取数据库连接时时都进行锁定，会降低 ShardingSphere 的并发。因此，ShardingSphere 在这里进行了 2 点优化：
 1. 避免锁定一次性只需要获取1个数据库连接的操作。因为每次仅需要获取 1 个连接，则不会发生两个请求相互等待的场景，无需锁定。 对于大部分 OLTP 的操作，都是使用分片键路由至唯一的数据节点，
 这会使得系统变为完全无锁的状态，进一步提升了并发效率。 除了路由至单分片的情况，读写分离也在此范畴之内。
 2. 仅针对内存限制模式时才进行资源锁定。在使用连接限制模式时，所有的查询结果集将在装载至内存之后释放掉数据库连接资源，因此不会产生死锁等待的问题。
 
 **执行阶段**
 
 该阶段用于真正的执行 SQL，它分为分组执行和归并结果集生成两个步骤。<br/>
 
 分组执行将准备执行阶段生成的执行单元分组下发至底层并发执行引擎，并针对执行过程中的每个关键步骤发送事件。 如：执行开始事件、执行成功事件以及执行失败事件。执行引擎仅关注事件的发送，
 它并不关心事件的订阅者。 ShardingSphere 的其他模块，如：分布式事务、调用链路追踪等，会订阅感兴趣的事件，并进行相应的处理。<br/>
 
 ShardingSphere 通过在执行准备阶段的获取的连接模式，生成内存归并结果集或流式归并结果集，并将其传递至结果归并引擎，以进行下一步的工作。<br/>
 
 执行引擎的整体结构划分如下图所示。<br/>
<img src="./media/pictures/sharding-jdbc/execute_architecture_cn.png" />

### 归并引擎

将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。<br/>

ShardingSphere 支持的结果归并从功能上分为遍历、排序、分组、分页和聚合 5 种类型，它们是组合而非互斥的关系。 从结构划分，可分为流式归并、内存归并和装饰者归并。
流式归并和内存归并是互斥的，装饰者归并可以在流式归并和内存归并之上做进一步的处理。<br/>

由于从数据库中返回的结果集是逐条返回的，并不需要将所有的数据一次性加载至内存中，因此，在进行结果归并时，沿用数据库返回结果集的方式进行归并，能够极大减少内存的消耗，是归并方式的优先选择。<br/>

流式归并是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。遍历、排序以及流式分组都属于流式归并的一种。<br/>

内存归并则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。<br/>

装饰者归并是对所有的结果集归并进行统一的功能增强，目前装饰者归并有分页归并和聚合归并这 2 种类型。<br/>

**遍历归并**

它是最为简单的归并方式。 只需将多个数据结果集合并为一个单向链表即可。在遍历完成链表中当前数据结果集之后，将链表元素后移一位，继续遍历下一个数据结果集即可。<br/>

**排序归并**

由于在 SQL 中存在 ORDER BY 语句，因此每个数据结果集自身是有序的，因此只需要将数据结果集当前游标指向的数据值进行排序即可。 这相当于对多个有序的数组进行排序，
归并排序是最适合此场景的排序算法。<br/>

ShardingSphere 在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（通过实现 Java 的 Comparable 接口完成），并将其放入优先级队列。 每次获取下一条数据时，
只需将队列顶端结果集的游标下移，并根据新游标重新进入优先级排序队列找到自己的位置即可。<br/>

通过一个例子来说明 ShardingSphere 的排序归并，下图是一个通过分数进行排序的示例图。 图中展示了 3 张表返回的数据结果集，每个数据结果集已经根据分数排序完毕，
但是 3 个数据结果集之间是无序的。 将 3 个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列，t_score_0 的第一个数据值最大，t_score_2 的第一个数据值次之，
t_score_1 的第一个数据值最小，因此优先级队列根据 t_score_0，t_score_2 和 t_score_1 的方式排序队列。<br/>

<img src="./media/pictures/sharding-jdbc/order_by_merge_1.png" />

下图则展现了进行 next 调用的时候，排序归并是如何进行的。 通过图中我们可以看到，当进行第一次 next 调用时，排在队列首位的 t_score_0 将会被弹出队列，并且将当前游标指向的数据值
（也就是 100）返回至查询客户端，并且将游标下移一位之后，重新放入优先级队列。 而优先级队列也会根据 t_score_0 的当前数据结果集指向游标的数据值（这里是 90）进行排序，
根据当前数值，t_score_0 排列在队列的最后一位。 之前队列中排名第二的 t_score_2 的数据结果集则自动排在了队列首位。<br/>

在进行第二次 next 时，只需要将目前排列在队列首位的 t_score_2 弹出队列，并且将其数据结果集游标指向的值返回至客户端，并下移游标，继续加入队列排队，以此类推。
当一个结果集中已经没有数据了，则无需再次加入队列。<br/>

<img src="./media/pictures/sharding-jdbc/order_by_merge_2.png" />

可以看到，对于每个数据结果集中的数据有序，而多数据结果集整体无序的情况下，ShardingSphere 无需将所有的数据都加载至内存即可排序。 它使用的是流式归并的方式，
每次 next 仅获取唯一正确的一条数据，极大的节省了内存的消耗。<br/>

从另一个角度来说，ShardingSphere 的排序归并，是在维护数据结果集的纵轴和横轴这两个维度的有序性。 纵轴是指每个数据结果集本身，它是天然有序的，它通过包含 ORDER BY 的 SQL 所获取。 
横轴是指每个数据结果集当前游标所指向的值，它需要通过优先级队列来维护其正确顺序。 每一次数据结果集当前游标的下移，都需要将该数据结果集重新放入优先级队列排序，
而只有排列在队列首位的数据结果集才可能发生游标下移的操作。<br/>

**分组归并**

分组归并的情况最为复杂，它分为流式分组归并和内存分组归并。 流式分组归并要求 SQL 的排序项与分组项的字段以及排序类型（ASC 或 DESC）必须保持一致，否则只能通过内存归并才能保证其数据的正确性。 <br/>

举例说明，假设根据科目分片，表结构中包含考生的姓名（为了简单起见，不考虑重名的情况）和分数。通过 SQL 获取每位考生的总分，可通过如下 SQL：
```sql
SELECT name, SUM(score) FROM t_score GROUP BY name ORDER BY name;
```
在分组项与排序项完全一致的情况下，取得的数据是连续的，分组所需的数据全数存在于各个数据结果集的当前游标所指向的数据值，因此可以采用流式归并。如下图所示。 <br/>

<img src="./media/pictures/sharding-jdbc/group_by_merge_1_v3.png" />

进行归并时，逻辑与排序归并类似。 下图展现了进行 next 调用的时候，流式分组归并是如何进行的。<br/>

<img src="./media/pictures/sharding-jdbc/group_by_merge_2_v2.png" />

通过图中我们可以看到，当进行第一次 next 调用时，排在队列首位的 t_score_java 将会被弹出队列，并且将分组值同为 “Jerry” 的其他结果集中的数据一同弹出队列。 
在获取了所有的姓名为 “Jerry” 的同学的分数之后，进行累加操作，那么，在第一次 next 调用结束后，取出的结果集是 “Jerry” 的分数总和。 
与此同时，所有的数据结果集中的游标都将下移至数据值 “Jerry” 的下一个不同的数据值，并且根据数据结果集当前游标指向的值进行重排序。 
因此，包含名字顺着第二位的 “John” 的相关数据结果集则排在的队列的前列。<br/>

流式分组归并与排序归并的区别仅仅在于两点：
1. 它会一次性的将多个数据结果集中的分组项相同的数据全数取出。
2. 它需要根据聚合函数的类型进行聚合计算。

对于分组项与排序项不一致的情况，由于需要获取分组的相关的数据值并非连续的，因此无法使用流式归并，需要将所有的结果集数据加载至内存中进行分组和聚合。
 例如，若通过以下 SQL 获取每位考生的总分并按照分数从高至低排序：<br/>
 ```sql
SELECT name, SUM(score) FROM t_score GROUP BY name ORDER BY score DESC;
```
那么各个数据结果集中取出的数据与排序归并那张图的上半部分的表结构的原始数据一致，是无法进行流式归并的。<br/>

当 SQL 中只包含分组语句时，根据不同数据库的实现，其排序的顺序不一定与分组顺序一致。 但由于排序语句的缺失，则表示此 SQL 并不在意排序顺序。
因此，ShardingSphere 通过 SQL 优化的改写，自动增加与分组项一致的排序项，使其能够从消耗内存的内存分组归并方式转化为流式分组归并方案。<br/>

**聚合归并**

无论是流式分组归并还是内存分组归并，对聚合函数的处理都是一致的。 除了分组的 SQL 之外，不进行分组的 SQL 也可以使用聚合函数。
因此，聚合归并是在之前介绍的归并类的之上追加的归并能力，即装饰者模式。聚合函数可以归类为比较、累加和求平均值这 3 种类型。<br/>

比较类型的聚合函数是指 MAX 和 MIN。它们需要对每一个同组的结果集数据进行比较，并且直接返回其最大或最小值即可。<br/>

累加类型的聚合函数是指 SUM 和 COUNT。它们需要将每一个同组的结果集数据进行累加。<br/>

求平均值的聚合函数只有 AVG。它必须通过 SQL 改写的 SUM 和 COUNT 进行计算，相关内容已在 SQL 改写的内容中涵盖，不再赘述。<br/>

**分页归并**

上文所述的所有归并类型都可能进行分页。 分页也是追加在其他归并类型之上的装饰器，ShardingSphere 通过装饰者模式来增加对数据结果集进行分页的能力。 分页归并负责将无需获取的数据过滤掉。<br/>

ShardingSphere 的分页功能比较容易让使用者误解，用户通常认为分页归并会占用大量内存。 在分布式的场景中，将 LIMIT 10000000, 10 改写为 LIMIT 0, 10000010，才能保证其数据的正确性。
用户非常容易产生 ShardingSphere 会将大量无意义的数据加载至内存中，造成内存溢出风险的错觉。 其实，通过流式归并的原理可知，会将数据全部加载到内存中的只有内存分组归并这一种情况。
而通常来说，进行 OLAP 的分组 SQL，不会产生大量的结果数据，它更多的用于大量的计算，以及少量结果产出的场景。 除了内存分组归并这种情况之外，其他情况都通过流式归并获取数据结果集，
因此 ShardingSphere 会通过结果集的 next 方法将无需取出的数据全部跳过，并不会将其存入内存。<br/>

但同时需要注意的是，由于排序的需要，大量的数据仍然需要传输到 ShardingSphere 的内存空间。 因此，采用 LIMIT 这种方式分页，并非最佳实践。 由于 LIMIT 并不能通过索引查询数据，
因此如果可以保证 ID 的连续性，通过 ID 进行分页是比较好的解决方案，例如：
```sql
SELECT * FROM t_order WHERE id > 100000 AND id <= 100010 ORDER BY id;
```
或通过记录上次查询结果的最后一条记录的 ID 进行下一页的查询，例如：
```sql
SELECT * FROM t_order WHERE id > 10000000 LIMIT 10;
```
归并引擎的整体结构划分如下图。
<img src="./media/pictures/sharding-jdbc/merge_architecture_cn.png" />











