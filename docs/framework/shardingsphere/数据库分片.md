
## Sharding-jdbc概览

**ShardingSphere-JDBC**

定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 
它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。

- 适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。
- 支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。
- 支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。
 
 <img src="./media/pictures/sharding-jdbc/sharding-jdbc_v5.png" />
 

## 快速入门

**引入maven依赖**

```java
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>shardingsphere-jdbc-core</artifactId>
    <version>5.0.0</version>
</dependency>
```

**规则配置**

Sharding-jdbc可以通过 java、yaml、spring命名空间、spring boot starter这四种方式进行配置。

**创建数据源**

通过 ShardingSphereDataSourceFactory 工厂和规则配置对象获取 ShardingSphereDataSource。 该对象实现自 JDBC 的标准 DataSource 接口，可用于原生 JDBC 开发，或使用 JPA, MyBatis 等 ORM 类库。

##  概览

### 数据分片

#### 背景
    
传统的将数据集中存储单一解决的解决方案，在性能、可用性、运营成本这个三方面已经难以满足海量数据的场景。<br/><br/>
从性能方面来说，由于关系型数据库大多采用的B+树的索引类型，在数据量超过阈值的情况下，索引深度的增加也将使磁盘访问IO的次数增多，进度导致查询性能下降，
同时高并发请求也使得集中式数据库成为系统的最大瓶颈。<br/><br/>

从可用性的方面来说，服务化的无状态型，能够达到较小成本的所以扩容，这必然导致系统的最终压力都落在数据库上面了。而单一的数据节点，或者简单的主从架构，
已经难以承担，数据库的可用性，已成为整个系统的关键。<br/><br/>

从运营成本方面来说，当一个数据库实例中的数据达到阈值以上，对于DBA的运维压力就会增大，数据备份和恢复的时间都将随着数据量的大小愈发不可控，一般来讲，
单一数据库的存储阈值在1T之内都是比较合理的范围。<br/><br/>

传统的关系型数据库无法满足互联网产品场景的情况下，将数据存储至原生支持分布式的NoSql的方案越来越多。但是NoSql对Sql的不兼容性及生态圈的不完善性，使得它们在与关系型数据库的博弈中
始终无法完成致命的一击，而关系型数据库的地位依然不可撼动。<br/><br/>

数据分片是指按照某个维度将存放在单一数据库的数据分散地存放至多个数据库或表中以达到提升性能瓶颈及可用性的效果，数据分片的有效手段是对关系型数据库进行分库和分表。分库分表均可以有效
避免由数据量超过可承受阈值而产生的查询瓶颈。除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库的压力，但却能够提供尽量将分布式事务转化为本地事务的可能，
一旦涉及跨库的更新操作，分布式事务往往会使问题变得更复杂。使用多主多从的分片方式，可以有效规避数据单点，从而提升数据架构的可用性。<br/><br/>

通过分库和分表进行数据的拆分使得各个表的数据量保持阈值以下，以及对数据进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段，数据分片的拆分方式又分为垂直拆分和水平拆分。<br/><br/>

**垂直分片**

垂直分片又成纵向分片，它的核心理念就是专库专用。在拆分之前，一个数据库有多个表构成，每个表对应这不同的业务。而拆分之后，则是按照业务将表归类，分布到不同的数据库中，从而将压力分散至不同的数据库。
下图展示了根据业务需要，将用户表和订单表分片到不同的数据库方案。

 <img src="./media/pictures/sharding-jdbc/vertical_sharding.png" /><br/>
 
 垂直切片往往需要对架构进行调整，通常来讲，是不足以应对互联网业务需求快速变化的；而且它无法从根本上解决数据库的单点瓶颈。不过垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分
 之后，表中的数据量依然超过单节点所能承受的阈值，则需要水平分片来进一步处理。

**水平拆分**

水平拆分又称横向拆分，相对于垂直拆分，它不再将数据根据业务逻辑分类，而且通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或多个表，每个分片仅包含数据的一部分。例如:根据主键分片，
偶数主键入A库（或表），奇数主键入B库（或表），入下图所示：

 <img src="./media/pictures/sharding-jdbc/horizontal_sharding.png" /><br/>

水平分片从理论上来讲，突破了单机数据量处理的瓶颈，并且扩展相对自由，是数据分片的标准方案。

#### 挑战

虽然数据分片解决了性能、可用以及单点备份恢复等问题，但分布式的结构在获得收益的同时，也引入了新的问题。<br/>
1. 面对如此散乱的分片之后的数据，应用开发工程师和数据库管理员对数据库的操作变得异常繁重。因为他们需要知道需要从哪个具体的数据库的子表中获取数据。
2. 能正确运行在单点的sql，在分片之后数据库运行不一定正确。例如：分表导致表名的修改，或者分页、排序、聚合分组等操作的不正确处理。
3. 跨库事务也是分布式数据集群一个棘手的问题。合理的采用分表，可以在降低单表数据量的情况下，尽快使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦问题。在不能避免跨库事务的场景，
有些业务扔需要保持事务的一致性，而基于XA的分布式事务由于在并发度高的场景中性能无法满足需要，从而并未被互联网公司大规模使用。他们大多数采用最终一致性的柔性事务代替强一致性事务。

#### 目标

尽量透明分库分表所带来的影响，让使用方尽快像使用一个数据库一样使用水平分片之后的数据库集群。是Apache ShardingSphere数据切换模块的主要设计目标。


## 分片引擎

### 解析引擎

### 路由引擎

根据解析上下文匹配数据库和表的分片策略，并生产路由路径。对于携带分片键的SQL，根据分片键不同可以划分单片路由（分片键的操作符是符号）、多片路由（分片键的操作符是In）和范围路由
（分片键的操作是Between）。不携带分片键的SQL则采用广播路由。<br/>
分片策略通常可以采用数据库内置或用户方配置。数据库内置的方案较为简单，内置的分片策略大致可分为尾数取模、哈希、范围、标签、时间等等，有用户方配置的分片策略则更加灵活，可以根据用户方需求
定制复合分片策略。如果配合数据自动迁移来使用，可以做到无需用户关注分片策略，自动由数据库中间层分片和平衡数据即可。


###### 分片路由

用户根据分片键路由的场景，又细分为直接路由、标准路由、笛卡尔积路由这3中类型。
    
**直接路由**    

满足直接路由的条件相对苛刻，它需要通过Hint（使用HintAPI直接指定路由至库表）方式分片，并且只分库不分表的前提下，则可以避免SQL解析和之后的结果归并。因此它的性能最好，可以执行包括子查询、
自定义函数等复杂的情况的任意SQL。直接路由还可以用户分片键不在SQL中的场景。例如，设置用于数据库分片的键为3

```java
hintManager.setDatabaseShardingValue(3);
```

假如路由算法为 value % 2，当一个逻辑库 t_order 对应 2 个真实库 t_order_0 和 t_order_1 时，路由后 SQL 将在 t_order_1 上执行。下方是使用 API 的代码样例：

```java
String sql = "SELECT * FROM t_order";
try (
        HintManager hintManager = HintManager.getInstance();
        Connection conn = dataSource.getConnection();
        PreparedStatement pstmt = conn.prepareStatement(sql)) {
    hintManager.setDatabaseShardingValue(3);
    try (ResultSet rs = pstmt.executeQuery()) {
        while (rs.next()) {
            //...
        }
    }
}
```



**标准路由**    

标准路由是 ShardingSphere 最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的 SQL。 当分片运算符是等于号时，路由结果将落入单库（表），
当分片运算符是 BETWEEN 或 IN 时，则路由结果不一定落入唯一的库（表），因此一条逻辑 SQL 最终可能被拆分为多条用于执行的真实 SQL。 举例说明，如果按照 order_id 的奇数和偶数进行数据分片，
一个单表查询的 SQL 如下：

```sql
SELECT * FROM t_order WHERE order_id IN (1, 2);
```
那么路由的结果应为：

```sql
SELECT * FROM t_order_0 WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 WHERE order_id IN (1, 2);
```
绑定表的关联查询与单表查询复杂度和性能相当。举例说明，如果一个包含绑定表的关联查询的 SQL 如下：

```sql
SELECT * FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```

那么路由的结果应为：

```sql
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```
可以看到，SQL 拆分的数目与单表是一致的。

**笛卡尔积路由**  
  
笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行。 如果上个示例中的 SQL 并未配置绑定表关系，那么路由的结果应为：
```sql
SELECT * FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
SELECT * FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id  WHERE order_id IN (1, 2);
```
笛卡尔路由查询性能较低，需谨慎使用。
   
###### 广播路由

对于不携带分片键的 SQL，则采取广播路由的方式。根据 SQL 类型又可以划分为全库表路由、全库路由、全实例路由、单播路由和阻断路由这 5 种类型。

###### 全库表路由

全库表路由用于处理对数据库中与其逻辑表相关的所有真实表的操作，主要包括不带分片键的 DQL 和 DML，以及 DDL 等。例如：

```sql
SELECT * FROM t_order WHERE good_prority IN (1, 10);
```
则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配得上则执行。路由后成为

```sql
SELECT * FROM t_order_0 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_1 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_2 WHERE good_prority IN (1, 10);
SELECT * FROM t_order_3 WHERE good_prority IN (1, 10);
```

###### 全库路由

全库路由用于处理对数据库的操作，包括用于库设置的 SET 类型的数据库管理命令，以及 TCL 这样的事务控制语句。 在这种情况下，会根据逻辑库的名字遍历所有符合名字匹配的真实库，
并在真实库中执行该命令，例如：

```sql
SET autocommit=0;
```

在 t_order 中执行，t_order 有 2 个真实库。则实际会在 t_order_0 和 t_order_1 上都执行这个命令。

###### 全实例路由

全实例路由用于 DCL 操作，授权语句针对的是数据库的实例。无论一个实例中包含多少个 Schema，每个数据库的实例只执行一次。例如：
```sql
CREATE USER customer@127.0.0.1 identified BY '123';
```
这个命令将在所有的真实数据库实例中执行，以确保 customer 用户可以访问每一个实例。

###### 单播路由

单播路由用于获取某一真实表信息的场景，它仅需要从任意库中的任意真实表中获取数据即可。例如：
```sql
DESCRIBE t_order;
```
t_order 的两个真实表 t_order_0，t_order_1 的描述结构相同，所以这个命令在任意真实表上选择执行一次。

###### 阻断路由

阻断路由用于屏蔽 SQL 对数据库的操作，例如：
```sql
USE order_db;
```
这个命令不会在真实数据库中执行，因为 ShardingSphere 采用的是逻辑 Schema 的方式，无需将切换数据库 Schema 的命令发送至数据库中。<br/>
路由引擎的整体结构划分如下图。

 <img src="./media/pictures/sharding-jdbc/route_architecture.png" />

### 改写引擎

工程师面向逻辑库与逻辑表书写的 SQL，并不能够直接在真实的数据库中执行，SQL 改写用于将逻辑 SQL 改写为在真实数据库中可以正确执行的 SQL。 它包括正确性改写和优化改写两部分。

**正确性改写**

在包含分表的场景中，需要将分表配置中的逻辑表名称改写为路由之后所获取的真实表名称。仅分库则不需要表名称的改写。除此之外，还包括补列和分页信息修正等内容。

**标识符改写**

需要改写的标识符包括表名称、索引名称以及 Schema 名称。<br/>

表名称改写是指将找到逻辑表在原始 SQL 中的位置，并将其改写为真实表的过程。表名称改写是一个典型的需要对 SQL 进行解析的场景。 从一个最简单的例子开始，若逻辑 SQL 为：
```sql
SELECT order_id FROM t_order WHERE order_id=1;
```
假设该 SQL 配置分片键 order_id，并且 order_id=1 的情况，将路由至分片表 1。那么改写之后的 SQL 应该为：
```sql
SELECT order_id FROM t_order_1 WHERE order_id=1;
```
在这种最简单的 SQL 场景中，是否将 SQL 解析为抽象语法树似乎无关紧要，只要通过字符串查找和替换就可以达到 SQL 改写的效果。
但是下面的场景，就无法仅仅通过字符串的查找替换来正确的改写 SQL 了：
```sql
SELECT order_id FROM t_order WHERE order_id=1 AND remarks=' t_order xxx';
```
正确改写的 SQL 应该是：
```sql
SELECT order_id FROM t_order_1 WHERE order_id=1 AND remarks=' t_order xxx';
```
而非
```sql
SELECT order_id FROM t_order_1 WHERE order_id=1 AND remarks=' t_order_1 xxx';
```
由于表名之外可能含有表名称的类似字符，因此不能通过简单的字符串替换的方式去改写 SQL。<br/>
下面再来看一个更加复杂的 SQL 改写场景：
```sql
SELECT t_order.order_id FROM t_order WHERE t_order.order_id=1 AND remarks=' t_order xxx';
```
上面的 SQL 将表名作为字段的标识符，因此在 SQL 改写时需要一并修改：
```sql
SELECT t_order_1.order_id FROM t_order_1 WHERE t_order_1.order_id=1 AND remarks=' t_order xxx';
```
而如果 SQL 中定义了表的别名，则无需连同别名一起修改，即使别名与表名相同亦是如此。例如：
```sql
SELECT t_order.order_id FROM t_order AS t_order WHERE t_order.order_id=1 AND remarks=' t_order xxx';
```
SQL 改写则仅需要改写表名称就可以了：
```sql
SELECT t_order.order_id FROM t_order_1 AS t_order WHERE t_order.order_id=1 AND remarks=' t_order xxx';
```

**补列**

需要在查询语句中补列通常由两种情况导致。 第一种情况是 ShardingSphere 需要在结果归并时获取相应数据，但该数据并未能通过查询的 SQL 返回。 
这种情况主要是针对 GROUP BY 和 ORDER BY。结果归并时，需要根据 GROUP BY 和 ORDER BY 的字段项进行分组和排序，
但如果原始 SQL 的选择项中若并未包含分组项或排序项，则需要对原始 SQL 进行改写。 先看一下原始 SQL 中带有结果归并所需信息的场景：
```sql
SELECT order_id, user_id FROM t_order ORDER BY user_id;
```
由于使用 user_id 进行排序，在结果归并中需要能够获取到 user_id 的数据，而上面的 SQL 是能够获取到 user_id 数据的，因此无需补列。<br/>
如果选择项中不包含结果归并时所需的列，则需要进行补列，如以下 SQL：
```sql
SELECT order_id FROM t_order ORDER BY user_id;
```
由于原始 SQL 中并不包含需要在结果归并中需要获取的 user_id，因此需要对 SQL 进行补列改写。补列之后的 SQL 是：
```sql
SELECT order_id, user_id AS ORDER_BY_DERIVED_0 FROM t_order ORDER BY user_id;
```
值得一提的是，补列只会补充缺失的列，不会全部补充，而且，在 SELECT 语句中包含 * 的 SQL，也会根据表的元数据信息选择性补列。下面是一个较为复杂的 SQL 补列场景：
```sql
SELECT o.* FROM t_order o, t_order_item i WHERE o.order_id=i.order_id ORDER BY user_id, order_item_id;
```
我们假设只有 t_order_item 表中包含 order_item_id 列，那么根据表的元数据信息可知，在结果归并时，排序项中的 user_id 是存在于 t_order 表中的，无需补列；
order_item_id 并不在 t_order 中，因此需要补列。 补列之后的 SQL 是：
```sql
SELECT o.*, order_item_id AS ORDER_BY_DERIVED_0 FROM t_order o, t_order_item i WHERE o.order_id=i.order_id ORDER BY user_id, order_item_id;
```
补列的另一种情况是使用 AVG 聚合函数。在分布式的场景中，使用 avg1 + avg2 + avg3 / 3 计算平均值并不正确，需要改写为 (sum1 + sum2 + sum3) / (count1 + count2 + count3)。
这就需要将包含 AVG 的 SQL 改写为 SUM 和 COUNT，并在结果归并时重新计算平均值。例如以下 SQL：
```sql
SELECT AVG(price) FROM t_order WHERE user_id=1;
```
需要改写为：
```sql
SELECT COUNT(price) AS AVG_DERIVED_COUNT_0, SUM(price) AS AVG_DERIVED_SUM_0 FROM t_order WHERE user_id=1;
```
然后才能够通过结果归并正确的计算平均值。<br/>

最后一种补列是在执行 INSERT 的 SQL 语句时，如果使用数据库自增主键，是无需写入主键字段的。 但数据库的自增主键是无法满足分布式场景下的主键唯一的
，因此 ShardingSphere 提供了分布式自增主键的生成策略，并且可以通过补列，让使用方无需改动现有代码，即可将分布式自增主键透明的替换数据库现有的自增主键。
 分布式自增主键的生成策略将在下文中详述，这里只阐述与 SQL 改写相关的内容。 举例说明，假设表 t_order 的主键是 order_id，原始的 SQL 为：
```sql
INSERT INTO t_order (`field1`, `field2`) VALUES (10, 1);
```
可以看到，上述 SQL 中并未包含自增主键，是需要数据库自行填充的。ShardingSphere 配置自增主键后，SQL 将改写为：
```sql
INSERT INTO t_order (`field1`, `field2`, order_id) VALUES (10, 1, xxxxx);
```
改写后的 SQL 将在 INSERT FIELD 和 INSERT VALUE 的最后部分增加主键列名称以及自动生成的自增主键值。上述 SQL 中的 xxxxx 表示自动生成的自增主键值。
如果 INSERT 的 SQL 中并未包含表的列名称，ShardingSphere 也可以根据判断参数个数以及表元信息中的列数量对比，并自动生成自增主键。例如，原始的 SQL 为：
```sql
INSERT INTO t_order VALUES (10, 1);
```
改写的 SQL 将只在主键所在的列顺序处增加自增主键即可：
```sql
INSERT INTO t_order VALUES (xxxxx, 10, 1);
```
自增主键补列时，如果使用占位符的方式书写 SQL，则只需要改写参数列表即可，无需改写 SQL 本身。

**分页修正**

### 执行引擎

### 归并引擎













